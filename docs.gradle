buildscript {
    repositories {
        mavenCentral()
    }
    dependencies {
        classpath 'org.freemarker:freemarker:2.3.26-incubating'
    }
}

import groovy.io.FileType

def outputPath = "docs/generated"
def templatePath = "docs/templates"
def helpPropertiesPath = "docs/data/help.properties"

task helpJson(type: JavaExec) {
    dependsOn build

    classpath = files(createArtifactName())
    classpath += sourceSets.main.runtimeClasspath
    main = 'com.synopsys.integration.detect.Application'
    args = ['--helpjson']
}

task helpData() {
    dependsOn helpJson
    doLast {
        def jsonHelpFile = "synopsys-detect-${version}-help.json"
        def helpJson = new groovy.json.JsonSlurper().parseText(file(jsonHelpFile).text)
        Properties helpProperties = new Properties()
        File propertiesFile = new File(helpPropertiesPath)
        propertiesFile.withInputStream {
            helpProperties.load(it)
        }
        helpProperties.setProperty("program_version", "${version}")
        helpJson.properties = helpProperties

        def cfg = new freemarker.template.Configuration()
        cfg.setDirectoryForTemplateLoading(file(templatePath))
        cfg.setDefaultEncoding("UTF-8")

        def output = file(outputPath)
        if (output.exists()) {
            println "Cleaning existing output directory: ${output}"
            output.deleteDir()
        }
        output.mkdirs()

        helpData.ext.helpJson = helpJson
        helpData.ext.templates = cfg
        helpData.ext.output = output
    }
}

task propertiesFolder() {
    dependsOn helpData
    doLast {
        def propertiesFile = new File(helpData.output, "properties")
        if (propertiesFile.exists()) {
            propertiesFile.deleteDir()
        }
        propertiesFile.mkdirs()

        propertiesFolder.ext.asFile = propertiesFile
    }
}

task generatedPropertyMarkdown() {
    dependsOn helpData
    dependsOn propertiesFolder
    doLast {
        def groups = []
        helpData.helpJson.options.forEach { property ->
            def found = groups.find { group -> group.groupName == property.group }
            if (found == null) {
                found = [groupName: property.group, superGroup: property.superGroup, options: []]
                groups.add(found)
            }
            found.options.add(property)
        }

        def simple_groups = []
        def split_groups = []
        groups.forEach { group ->
            def template = helpData.templates.getTemplate("property-group.ftl")
            def parentFolder = propertiesFolder.asFile;
            if (group.superGroup) {
                parentFolder = new File(parentFolder, group.superGroup)
                parentFolder.mkdirs()
                group.location = group.superGroup + "/" + group.groupName
            } else {
                parentFolder = new File(parentFolder, "Configuration")
                parentFolder.mkdirs()
                group.location = "Configuration/" + group.groupName
            }

            def target = new File(parentFolder, "${group.groupName}.md")
            def simple = []
            def advanced = []
            def deprecated = []
            group.options.forEach { property ->
                property.location = parentFolder.getName() + "/" + group.groupName + "#" + property.propertyName.replaceAll(" ", "-");
                if (property.deprecated) {
                    deprecated.add(property)
                } else if (property.category == "simple") {
                    simple.add(property)
                } else {
                    advanced.add(property)
                }
            }
            def split_group = [groupName: group.groupName, simple: simple, advanced: advanced, deprecated: deprecated, location: group.location]
            split_groups.add(split_group)
            target.withWriter('utf-8') { out -> template.process(split_group, out) }
            group.options = simple
            if (simple.size() > 0) {
                simple_groups.add(group)
            }
            println("Created: ${target}")
        }

        simple_groups.forEach { group -> group.options.sort { it.propertyKey } }
        split_groups.forEach { group -> group.simple.sort { it.propertyKey }; group.advanced.sort { it.propertyKey }; group.deprecated.sort { it.propertyKey } }

        def basicpropertiestemplate = helpData.templates.getTemplate("basic-properties.ftl")
        def basicpropertiesmd = new File(propertiesFolder.asFile, "basic-properties.md")
        basicpropertiesmd.withWriter('utf-8') { out -> basicpropertiestemplate.process([groups: simple_groups], out) }

        def allpropertiestemplate = helpData.templates.getTemplate("all-properties.ftl")
        def allpropertiesmd = new File(propertiesFolder.asFile, "all-properties.md")
        allpropertiesmd.withWriter('utf-8') { out -> allpropertiestemplate.process([groups: split_groups], out) }

    }
}

task generatedExitCodeMarkdown() {
    dependsOn helpData
    doLast {
        def exitCodeTemplate = helpData.templates.getTemplate("exit-codes.ftl")
        def exitCodeMd = new File(helpData.output, "exit-codes.md")
        exitCodeMd.withWriter('utf-8') { out -> exitCodeTemplate.process(helpData.helpJson, out) }
    }
}

task generatedDetectorMarkdown() {
    dependsOn helpData
    doLast {
        def buildGroups = []
        helpData.helpJson.buildDetectors.forEach { detector ->
            def found = buildGroups.find { group -> group.groupName == detector.detectorType }
            if (found == null) {
                found = [groupName: detector.detectorType, detectors: []]
                buildGroups.add(found)
            }
            found.detectors.add(detector.detectorName)
        }

        def buildlessGroups = []
        helpData.helpJson.buildlessDetectors.forEach { detector ->
            def found = buildlessGroups.find { group -> group.groupName == detector.detectorType }
            if (found == null) {
                found = [groupName: detector.detectorType, detectors: []]
                buildlessGroups.add(found)
            }
            found.detectors.add(detector.detectorName)
        }

        buildGroups.sort { it.groupName }
        buildlessGroups.sort { it.groupName }

        def template = helpData.templates.getTemplate("detectors.ftl")
        def markdown = new File(helpData.output, "detectors.md")
        markdown.withWriter('utf-8') { out -> template.process([build: buildGroups, buildless: buildlessGroups], out) }
    }
}

task generatedContent() {
    dependsOn helpData
    doLast {
        new File("${projectDir}/docs/templates/content").eachFile(FileType.FILES) { file ->
            String fmTemplateFilename = file.getName()
            def fmTemplate = helpData.templates.getTemplate("content/${fmTemplateFilename}")
            String mdFilename = fmTemplateFilename.take(fmTemplateFilename.lastIndexOf('.')) + ".md"
            def mdFile = new File(helpData.output, mdFilename)
            mdFile.withWriter('utf-8') { out -> fmTemplate.process(helpData.ext.helpJson.properties, out) }
        }
    }
}

task docs() {
    dependsOn generatedContent
    dependsOn generatedPropertyMarkdown
    dependsOn generatedExitCodeMarkdown
    dependsOn generatedDetectorMarkdown

    doLast {
        exec {
            commandLine 'mkdocs', 'build'
            workingDir "docs"
        }
    }
}