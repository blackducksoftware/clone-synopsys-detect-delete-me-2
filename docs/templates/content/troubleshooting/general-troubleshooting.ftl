# Troubleshooting best practices

1. Run ${solution_name} with `--logging.level.com.synopsys.integration=DEBUG` (the default logging level, INFO, is insufficient for troubleshooting) and read through the entire log for clues.
1. Better still: Run ${solution_name} with `-d`. This will generate a diagnostic zip that contains many useful intermediate files and logs, including the generated BDIO (.jsonld) files and signature scanner logs.
1. See if you can reproduce the problem using the latest version of ${solution_name} with the latest version of Black Duck. If not, the problem may be either fixed, or due to incompatible ${solution_name} / Black Duck versions.
1. Remember to consider the possibility that the Black Duck user lacks the necessary permissions (to create the project, update the BOM, receive notifications, etc.) in Black Duck.
1. Remember to consider the possibility that the Black Duck server (registration key) may not have required capabilities enabled (binary upload, snippet scanning, etc.).
1. For issues related to tools invoked by ${solution_name} (Black Duck signature scanner, Docker Inspector, etc.), please check that tool's documentation.
1. For issues related to incorrect components in the Black Duck BOM: ${solution_name} has a great deal of control over matches produced by Detectors (that are written to BDIO/.jsonld files), but no control over matches produced by the signature scanner. When investigating an incorrect component in a Black Duck BOM, you need to determine whether the component was contributed by a Detector, or by the signature scanner: On the Black Duck Components tab for the project/version: Click on the "N Matches" link next to the component. The next screen lists the matches on the right side. Matches from the signature scanner have a filename in the Name column. Matches from Detectors have an external ID (such as "org.hamcrest:hamcrest-core:1.3") in the Name column.
1. For issues related to components missing from or or incorrectly categorized in the Black Duck BOM: ${solution_name} has a great deal of control over the production of .jsonld files (use -d to save these), but no control over how they are converted into a BOM by Black Duck. A good first step is to determine whether the .jsonld files produced are correct. If they are incorrect, the problem is related to what ${solution_name} is doing. If they are correct, but the BOM is incorrect, the problem is related to what Black Duck is doing. Similarly, ${solution_name} is responsible for passing the correct arguments to the signature scanner, but has little control over the results it produces.
1. ${solution_name} is a Spring Boot application, and leverages Spring Boot to provide various mechanism to configure it through property settings: https://docs.spring.io/spring-boot/docs/current/reference/html/boot-features-external-config.html. This flexibility comes with a risk: it's possible for ${solution_name} to be influenced by files (application.properties, application.xml) that may exist in the directory from which ${solution_name} is run that are intended for some other application. This can produce some strange results. If properties have unexpected values (see the ${solution_name} log), this is a possibility worth considering. The best solution may be simply to run ${solution_name} from a different (ideally empty) directory (use the --detect.source.path argument).
1. Similarly, ${solution_name} can be influenced by environment variables via the same Spring Boot mechanism, so it's worth checking the environment for variables that correspond to ${solution_name} property names.